import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import { NextRequest } from 'next/server';
import path from 'path';

// Mock fs/promises
vi.mock('fs/promises', () => ({
  writeFile: vi.fn(),
  mkdir: vi.fn(),
  copyFile: vi.fn(),
  readdir: vi.fn(),
  rm: vi.fn(),
  default: {
    writeFile: vi.fn(),
    mkdir: vi.fn(),
    copyFile: vi.fn(),
    readdir: vi.fn(),
    rm: vi.fn(),
  },
}));

// Mock fs
vi.mock('fs', () => ({
  existsSync: vi.fn().mockReturnValue(true),
  default: {
    existsSync: vi.fn().mockReturnValue(true),
  },
}));

// Mock AdmZip
vi.mock('adm-zip', () => {
  const AdmZipMock = vi.fn().mockImplementation(() => ({
    extractAllTo: vi.fn(),
    getEntries: vi.fn().mockReturnValue([]),
    extractEntryTo: vi.fn(),
  }));
  return {
    default: AdmZipMock,
  };
});

// Import the route handler AFTER mocking
import { POST } from '@/app/api/internal/save-content/route';
import fsPromises from 'fs/promises';
import AdmZip from 'adm-zip';

describe('Save Content API Security', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should prevent path traversal via fileName', async () => {
    const maliciousFileName = '../../pwned.html';
    const request = new NextRequest(
      'http://localhost:3000/api/internal/save-content',
      {
        method: 'POST',
        body: JSON.stringify({
          fileName: maliciousFileName,
          type: 'game',
          subscriptionTier: 'free',
          content: '<html>malicious</html>',
          uploadSource: 'generated',
        }),
      }
    );

    const response = await POST(request);

    // Status 400 bad request due to validation
    expect(response.status).toBe(400);

    const mkdirMock = vi.mocked(fsPromises.mkdir);
    const writeFileMock = vi.mocked(fsPromises.writeFile);

    const maliciousDirCreated = mkdirMock.mock.calls.some((call) => {
      const dirPath = call[0] as string;
      return dirPath.includes('..') && !dirPath.includes('staging');
    });

    const maliciousFileWritten = writeFileMock.mock.calls.some((call) => {
      const filePath = call[0] as string;
      return filePath.includes('..') || filePath.includes('pwned');
    });

    expect(maliciousDirCreated).toBe(false);
    expect(maliciousFileWritten).toBe(false);
  });

  it('should prevent path traversal via uploadedZipPath', async () => {
    const maliciousZipPath = '../../etc/passwd';
    const request = new NextRequest(
      'http://localhost:3000/api/internal/save-content',
      {
        method: 'POST',
        body: JSON.stringify({
          fileName: 'safe-game.html',
          type: 'game',
          subscriptionTier: 'free',
          uploadedZipPath: maliciousZipPath,
          uploadSource: 'uploaded',
        }),
      }
    );

    const response = await POST(request);
    expect(response.status).toBe(400);

    const AdmZipMock = vi.mocked(AdmZip);
    const maliciousZipLoaded = AdmZipMock.mock.calls.some((call) => {
      const zipPath = call[0] as string;
      return zipPath.includes('..') || zipPath.includes('/etc/passwd');
    });

    expect(maliciousZipLoaded).toBe(false);
  });

  it('should allow valid input', async () => {
    const request = new NextRequest(
      'http://localhost:3000/api/internal/save-content',
      {
        method: 'POST',
        body: JSON.stringify({
          fileName: 'valid-game.html',
          type: 'game',
          subscriptionTier: 'free',
          content: '<html>valid</html>',
          uploadSource: 'generated',
        }),
      }
    );

    const response = await POST(request);

    // Status should be 200 OK
    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.success).toBe(true);

    const writeFileMock = vi.mocked(fsPromises.writeFile);
    expect(writeFileMock).toHaveBeenCalledWith(
      expect.stringContaining('valid-game.html'),
      expect.any(String),
      expect.any(String)
    );
  });
});
